from datetime import datetime, timedelta, timezone
from logging import Logger
from typing import Optional

import anduril.ontology.v1
from anduril.entitymanager.v1 import (
    EntityManagerApiStub,
    GetEntityRequest,
    GetEntityResponse,
    PublishEntityRequest,
    PublishEntityResponse,
    Entity,
    Aliases,
    AlternateId,
    AltIdType,
    MilView,
    Location,
    Position,
    Ontology,
    Template,
    Provenance,
    Classification,
    ClassificationInformation,
    ClassificationLevels
)
from grpclib.client import Channel

from ais import VesselData

EXPIRY_OFFSET_SECONDS = 10


class Lattice:
    def __init__(self, logger: Logger, lattice_ip: str, bearer_token: str, sandbox_token: str):
        self.logger = logger
        self.lattice_ip = lattice_ip
        self.generated_metadata = {"authorization": "Bearer " + bearer_token}
        if sandbox_token:
            self.generated_metadata["anduril-sandbox-authorization"] = f"Bearer {sandbox_token}"

    async def get_entity(self, entity_id) -> Optional[GetEntityResponse]:
        """
        Asynchronously retrieves an entity from the Lattice API using the provided entity ID.
        Usable wrapper around the get_entity API.
        For more information about this API, please refer to https://docs.anduril.com/sdks/python

        Args:
            entity_id (str): The ID of the entity to retrieve.

        Returns:
            Optional[GetEntityResponse]: The retrieved encased, or None if an error occurred.

        Raises:
            None

        """
        channel = Channel(host=self.lattice_ip, port=443, ssl=True)
        entity_manager_stub = EntityManagerApiStub(channel)

        try:
            response = await entity_manager_stub.get_entity(
                GetEntityRequest(entity_id=entity_id), metadata=self.generated_metadata
            )
            channel.close()
            return response
        except Exception as error:
            self.logger.error(f"lattice api get entity error {error}")
            channel.close()
            return None

    async def publish_entity(self, entity) -> Optional[PublishEntityResponse]:
        """
        Asynchronously publishes an entity to the Lattice API.
        Usable wrapper around the publish_entity API.
        For more information about this API, please refer to https://docs.anduril.com/entity/publishing-your-first-entity

        Args:
            entity (Entity): The entity to be published.

        Returns:
            Optional[PublishEntityResponse]: The response from the Lattice API, or None if an error occurred.

        Raises:
            None
        """
        channel = Channel(host=self.lattice_ip, port=443, ssl=True)
        entity_manager_stub = EntityManagerApiStub(channel)

        try:
            response = await entity_manager_stub.publish_entity(
                PublishEntityRequest(entity=entity),
                metadata=self.generated_metadata,
            )
            channel.close()
            return response
        except Exception as error:
            self.logger.error(f"lattice api publish entity error {error}")
            channel.close()
            return None

    @staticmethod
    def generate_new_entity(vessel_data: VesselData) -> Entity:
        """
        Generates a new entity using the provided VesselData.

        For more information about these data fields, please refer to
        https://docs.anduril.com/reference/models/entitymanager/v1/entity

        Args:
            vessel_data (VesselData): The data containing relevant information about the vessel.

        Returns:
            Entity: The generated entity with the basic attributes filled out:
                - entity_id: The vessel's MMSI.
                - description: A description of the vessel.
                - is_live: A boolean indicating whether the entity is live.
                - created_time: The time the entity was created.
                - expiry_time: The time the entity expires.
                - aliases: The aliases for the entity, including the vessel's MMSI.
                - mil_view: View of the entity.
                - location: The location of the entity, including latitude, longitude, and altitude.
                - ontology: The ontology for the entity, including the template, platform type, and specific type.
                - provenance: The provenance for the entity, including the data type, integration name, and source update time.
                - data_classification: The data classification for the entity, including the level of classification.
        """

        return Entity(
            entity_id=f"{vessel_data.MMSI}",  # Leaving this blank will generate an entityId
            description="Generated by AIS Vessel Traffic Dataset",
            is_live=True,
            created_time=datetime.now(timezone.utc),
            expiry_time=datetime.now(timezone.utc) + timedelta(seconds=EXPIRY_OFFSET_SECONDS),
            aliases=Aliases(
                name=vessel_data.VesselName,
                alternate_ids=[
                    AlternateId(
                        id=str(vessel_data.MMSI),
                        type=AltIdType.MMSI_ID,
                    )
                ],
            ),
            mil_view=MilView(
                disposition=anduril.ontology.v1.Disposition.NEUTRAL,
                environment=anduril.ontology.v1.Environment.SURFACE,
            ),
            location=Location(
                position=Position(
                    latitude_degrees=vessel_data.LAT,
                    longitude_degrees=vessel_data.LON,
                ),
            ),
            ontology=Ontology(
                template=Template.TRACK,
                # For more information, please refer to https://docs.anduril.com/entity/publishing-your-first-entity#define-ontology
                platform_type="Surface_Vessel",
            ),
            provenance=Provenance(
                data_type="vessel-data",
                integration_name="ais-sample-integration",
                source_update_time=datetime.now(timezone.utc),
            ),
            data_classification=Classification(
                default=ClassificationInformation(
                    level=ClassificationLevels.UNCLASSIFIED,
                )
            ),
        )
